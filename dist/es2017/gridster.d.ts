import { Disposable } from 'aurelia-binding';
import { GridsterCompact } from './services/gridster-compact';
import { GridsterConfig } from './interfaces/gridster-config';
import { GridsterEmptyCell } from './services/gridster-empty-cell';
import { GridsterGridCustomElement } from './gridster-grid';
import { GridsterItem } from './interfaces/gridster-item';
import { GridsterItemCustomElement } from './gridster-item';
import { Renderer } from './renderer';
export declare class GridsterCustomElement {
    renderer: Renderer;
    options: GridsterConfig;
    calculateLayoutDebounce: Function;
    movingItem: GridsterItem;
    previewStyle: Function;
    el: HTMLElement;
    $options: GridsterConfig;
    mobile: boolean;
    curWidth: number;
    curHeight: number;
    grid: Array<GridsterItemCustomElement>;
    columns: number;
    rows: number;
    curColWidth: number;
    curRowHeight: number;
    windowResize: Disposable | null;
    gridLines: GridsterGridCustomElement;
    dragInProgress: boolean;
    emptyCell: GridsterEmptyCell;
    compact: GridsterCompact;
    static checkCollisionTwoItems(item: GridsterItem, item2: GridsterItem): boolean;
    constructor(renderer: Renderer);
    attached(): void;
    resize(): void;
    setOptions(): void;
    optionsChanged2(): void;
    detached(): void;
    onResize(): void;
    checkIfToResize(): boolean;
    setGridSize(): void;
    setGridDimensions(): void;
    calculateLayout(): void;
    addItem(itemComponent: GridsterItemCustomElement): void;
    removeItem(itemComponent: GridsterItemCustomElement): void;
    checkCollision(item: GridsterItem): GridsterItemCustomElement | boolean;
    checkGridCollision(item: GridsterItem): boolean;
    findItemWithItem(item: GridsterItem): GridsterItemCustomElement | boolean;
    findItemsWithItem(item: GridsterItem): Array<GridsterItemCustomElement>;
    autoPositionItem(itemComponent: GridsterItemCustomElement): void;
    getNextPossiblePosition(newItem: GridsterItem): boolean;
    pixelsToPosition(x: number, y: number, roundingMethod: Function): [number, number];
    pixelsToPositionX(x: number, roundingMethod: Function): number;
    pixelsToPositionY(y: number, roundingMethod: Function): number;
    positionXToPixels(x: number): number;
    positionYToPixels(y: number): number;
}
